---
layout: default
parent: ClusterFuzzLite
title: Running ClusterFuzzLite
has_children: true
nav_order: 3
permalink: /running-clusterfuzzlite/
---
# Running ClusterFuzzLite
{: .no_toc}

- TOC
{:toc}
---

## Overview
![overview]({{ site.baseurl }}/assets/overview.png)

Once your project's fuzzers can be built and run by the OSS-Fuzz/ClusterFuzzLite
helper script, it is ready to be fuzzed by ClusterFuzzLite.
Make sure you've read the document on [integrating with ClusterFuzzLite's build
system] before reading this one if you are trying to set up ClusterFuzzLite.

The exact method for running ClusterFuzzLite will depend on the where you are
running ClusterFuzzLite (i.e. which CI system).
The rest of this page will explain general concepts and configuration options
that are important to understand but are agnostic to how ClusterFuzzLite is run.
After reading this page, you can check out the [subguides] for instructions how
to run them for your particular CI system (e.g. [GitHub Actions]).

## ClusterFuzzLite modes

ClusterFuzzLite offers two flavors of fuzzing: [code change fuzzing] and
[batch fuzzing].
ClusterFuzzLite also offers two helper modes for running fuzzers that don't
actually fuzz but provide useful functionality: [prune] and [coverage].
ClusterFuzzLite can be instructed to perform any of these functions using the
"mode" option.
The simplest way to use ClusterFuzzLite is to only do code change fuzzing, but
using the other modes in addition to code change fuzzing provides significant
benefits.
We will discuss these benefits, as well as the the high-level details of each of
these functions/modes and how they tie together below.
Don't worry if you don't understand everything, there are simple
instructions and examples that you can copy and paste to enable each mode in
the [subguides].

### Code Change Fuzzing ("code-change") {#code-change}

One of the core ways for using ClusterFuzzLite is for fuzzing code changes which
were introduced in a pull request/code review or commit.

Pull request fuzzing allows ClusterFuzzLite to find bugs before they are
commited into your code and while they are easiest to fix.
Note that we believe pull request fuzzing is sufficient and don't provide
guidance on commit fuzzing.

Code change fuzzing needs to be fast to be useful for developers.
This is the reason behind much of the design of code change fuzzing such as:
1. It defaults to running for 10 minutes, [though this can be changed].
2. It quits after finding a single crash, even if there are other fuzzers to
   run.
3. It relies on ClusterFuzzLite functionality done outside of code change
   fuzzing to offer some useful features, such as:
   - [Continuous builds]. These are used by ClusterFuzzLite to test if a
     crash was introduced by the code change or if it was pre-existing. If it
     was pre-existing, it is not reported by code change fuzzing. This is to
     prevent users from being bothered by crashes that already exist. Note
     though this does introduce some quirks: Code change fuzzing cannot be
     easily used to verify fixes of crashes that were not introduced in the
     change under test. Also, when you first use ClusterFuzzLite, code change
     fuzzing will not report the bugs that already exist in your codebase.
     [Batch fuzzing] will report these bugs, however. Note that if code change
     fuzzing does not have continuous builds, it will report all crashes.
   - [Batch fuzzing]. Batch fuzzing develops a corpus that is saved and used for
     other modes, including code change fuzzing. Code change fuzzing does not
     save a corpus because we don't know if the code being fuzzed will end up
     being committed to the codebase, and thus saving the corpus could result in
     useless testcases being saved. If code change fuzzing does not have a
     corpus to start with it will start from nothing or the provided seed
     corpus.
   - [Code coverage report generation]. Coverage data generated by this mode is
     used by code change fuzzing to determine which fuzzers are affected by a
     change. If code change fuzzing can determine which fuzzers are affected,
     it will only run those fuzzers. If code change fuzzing cannot determine
     which fuzzers are affected, it will run all of them.

Let's discuss the other modes and how they can help you independently of helping
code change fuzzing.

### Batch Fuzzing ("batch") {#batch}

ClusterFuzzLite can also run in a batch fuzzing mode where all fuzzers are run
for a longer amount of time. This shouldn't be done on code changes however,
since long running CI jobs are annoying for developers. It's better to run
batch fuzzing on a schedule, such as once daily.

Unlike in code change fuzzing, batch fuzzing will not exit immediately upon
discovering a bug, it will keep running other fuzzers until it reaches
the time allotted for fuzzing.

By running for a longer amount of time than code change fuzzing, batch fuzzing
serves two important purposes:
1. It can find bugs that are missed or are not reported by code change fuzzing.
   Note that batch fuzzing reports all crashes, not just "new" ones.
2. It builds a [corpus] for each of your fuzz targets, leading to more
   code coverage and better bug discovery.
   This corpus will be used by [Code coverage report generation],
   [code change fuzzing], and later runs of batch fuzzing.
   The corpus is saved using your CI system's feature for storing files.

[corpus]: https://github.com/google/fuzzing/blob/master/docs/glossary.md#corpus

### Corpus Pruning ("prune")

Over time, redundant testcases will get introduced into your fuzzer's corpuses
during [batch fuzzing].

Corpus pruning minimizes the corpuses by removing corpus files (testcases) that
do not increase the fuzzer's code coverage.

Running corpus pruning once a day will prevent buildup of these redundant
testcases and keep fuzzing efficient.

As discussed, pruning is a mode that helps [batch fuzzing]. It should be
considered required if you are using [batch fuzzing] but otherwise should not be
used.

### Code Coverage report generation ("coverage") {#coverage}

ClusterFuzzLite also provides code coverage report generation.
This will run your fuzzers on the corpus developed during [batch fuzzing] and
will generate an HTML coverage report you can read to see which parts of your
code are covered by fuzzing.
The data from coverage reports is also used by [code change fuzzing] to
determine which fuzzers are affected by a code change.

Coverage report generation uses the corpuses saved by [batch fuzzing] and
therefore should only be used if batch fuzzing is enabled. It is not required
if [batch fuzzing] is enabled, but is strongly recommended.

### Continuous builds

Continuous builds are not actually a mode of running fuzzers but is another
"task" for ClusterFuzzLite that you can set up. Instead of running the fuzzers
after building them, in continuous builds, the builds are saved for later use by
[code change fuzzing]. As discussed earlier, [code change fuzzing] uses the
saved builds to determine if crashes are novel.

Now that we've discussed the different ClusterFuzzLite tasks, let's look at some
configuration options that can be passed to ClusterFuzzLite.

## Configuration Options

Below are configuration options that you can set when running ClusterFuzzLite.
We will explain how to set these in each of the subguides.

- `language`: The language your target code is written in. Defaults to `c++`.
  This should be the same as the value you set in `project.yaml`. See [this
  explanation] for more details.

- `fuzz-seconds`: Instructs ClusterFuzzLite on how long to spend fuzzing, in
  seconds. The default is 600 seconds.

- `sanitizer`: Determines sanitizer to build and run fuzz targets with. The
  choices are `'address'`, and `'undefined'`. The default is `'address'`.

- `mode`: The mode for ClusterFuzzLite to execute. `code-change` by default. See
  [ClusterFuzzLite modes] for more details on how to run different modes.

- `dry-run`: Determines if ClusterFuzzLite reports bugs/crashes. The default
  value is `false`. When set to `true`, ClusterFuzzLite will never report a
  failure even if it finds a crash in your project. This requires the user to
  manually check the logs for detected bugs.

**Note:** How options are passed to ClusterFuzzLite will be determined by the CI
system being used. Because some CI systems will pass them using environment
variables, the names of the environment variables can be slightly different than
names of the corresponding options. In particular, environment variables will be
all uppercase and use underscores (`_`) instead of hyphens (`-`). For example:
the environment variable for `fuzz-seconds` is `FUZZ_SECONDS`.

At this point you are ready to run ClusterFuzzLite!
Follow the [subguide](#subguides) for your CI system to get started.

## Supported Continous Integration systems {#subguides}

- [GitHub Actions]
- [Google Cloud Build]

[subguides]: #subguides
[Google Cloud Build]: {{ site.baseurl }}/google-cloud-build/
[integrating with ClusterFuzzLite's build system]: {{ site.baseurl }}/build-integration/
[Batch Fuzzing]: #batch-fuzzing-batch
[Code Coverage report generation]: #code-coverage-report-generation-coverage
[this explanation]: {{ site.baseurl }}/build-integration/#language
[ClusterFuzzLite modes]: #clusterfuzzlite-modes
[GitHub Actions]: {{ site.baseurl }}/running-clusterfuzzlite/github-actions/
[Batch Fuzzing]: #batch
[Continuous builds]: #continuous-builds
[code change fuzzing]: #code-change
[prune]: #prune
[coverage]: #coverage
[though this can be changed]: #configuration-options
